(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{v18W:function(e,n,t){"use strict";t.r(n);var o=t("q1tI"),a=t.n(o),l=t("TJpk"),r=t("mcK/"),i=t("Ov9x"),s=t("2G++");n.default=function(){return a.a.createElement(a.a.Fragment,null,a.a.createElement(l.Helmet,null,a.a.createElement("meta",{name:"keywords",content:"\n            addEventListener, drag drop list, drag drop table row, getBoundingClientRect, insert node before,\n            insertBefore, mousedown event, mousemove event, mouseup event, next sibling,\n            nextElementSibling, previous sibling, previousElementSibling, sortable list, swap nodes\n        "})),a.a.createElement(i.a,{content:"\nBefore taking a look at this example, it's recommended to visit this [post](/drag-and-drop-element-in-a-list) to know\nhow we can drag and drop element in a list.\n\nNow we can use the same technique to apply to the table rows. The basic idea is\n\n* When user starts moving the table row, we create a list of items. Each item is cloned from each row of table.\n* We show the list at the same position as table, and hide the table.\n* At this step, moving row around is actually moving the list item.\n* When user drags an item, we determine the index of target item within the list. And move the original dragged row to before or after the\nrow associated with the end index.\n\nLet's get started with the basic markup of table:\n\n~~~ html\n<table id=\"table\">\n    ...\n</table>\n~~~\n\n## Basic setup\n\nAs mentioned in the [Drag and drop element in a list](/drag-and-drop-element-in-a-list) example, we need handle three events:\n\n* `mousedown` for the first cell of any row, so user can click and drag the first cell in each row\n* `mousemove` for `document`: This event triggers when user moves the row around, and we will create and insert a placeholder row\ndepending on the direction (up or down)\n* `mouseup` for `document`: This event occurs when user drags the row.\n\nHere is the skeleton of these event handlers:\n\n~~~ javascript\n// Query the table\nconst table = document.getElementById('table');\n\nconst mouseDownHandler = function(e) {\n    ...\n\n    // Attach the listeners to `document`\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler);\n};\n\nconst mouseMoveHandler = function(e) {\n    ...\n};\n\nconst mouseUpHandler = function() {\n    ...\n    // Remove the handlers of `mousemove` and `mouseup`\n    document.removeEventListener('mousemove', mouseMoveHandler);\n    document.removeEventListener('mouseup', mouseUpHandler);\n};\n\n// Query all rows\ntable.querySelectorAll('tr').forEach(function(row, index) {\n    // Ignore the header\n    // We don't want user to change the order of header\n    if (index === 0) {\n        return;\n    }\n\n    // Get the first cell of row\n    const firstCell = row.firstElementChild;\n    firstCell.classList.add('draggable');\n\n    // Attach event handler\n    firstCell.addEventListener('mousedown', mouseDownHandler);\n});\n~~~\n\n## Clone the table when user is moving a row\n\nSince this task is performed once, we need a flag to track if it's executed:\n\n~~~ javascript\nlet isDraggingStarted = false;\n\nconst mouseMoveHandler = function(e) {\n    if (!isDraggingStarted) {\n        isDraggingStarted = true;\n\n        cloneTable();\n    }\n    ...\n};\n~~~\n\n`cloneTable` creates an element that has the same position as the table, and is shown right before the table:\n\n~~~ javascript\nlet list;\n\nconst cloneTable = function() {\n    // Get the bounding rectangle of table\n    const rect = table.getBoundingClientRect();\n\n    // Get the width of table\n    const width = parseInt(window.getComputedStyle(table).width);\n\n    // Create new element\n    list = document.createElement('div');\n    \n    // Set the same position as table\n    list.style.position = 'absolute';\n    list.style.left = `${rect.left}px`;\n    list.style.top = `${rect.top}px`;\n\n    // Insert it before the table\n    table.parentNode.insertBefore(list, table);\n\n    // Hide the table\n    table.style.visibility = 'hidden';\n};\n~~~\n\nImagine that `list` consists of items which are cloned from the table rows:\n\n~~~ javascript\nconst cloneTable = function() {\n    ...\n\n    // Loop over the rows\n    table.querySelectorAll('tr').forEach(function(row) {\n        const item = document.createElement('div');\n\n        const newTable = document.createElement('table');\n        const newRow = document.createElement('tr');\n\n        // Query the cells of row\n        const cells = [].slice.call(row.children);\n        cells.forEach(function(cell) {\n            const newCell = cell.cloneNode(true);\n            newRow.appendChild(newCell);\n        });\n\n        newTable.appendChild(newRow);\n        item.appendChild(newTable);\n\n        list.appendChild(item);\n    });\n};\n~~~\n\nAfter this step, we have the following `list`:\n\n~~~ html\n\x3c!-- The list --\x3e\n<div>\n    \x3c!-- First item --\x3e\n    <div>\n        <table>\n            \x3c!-- The first row of original table --\x3e\n            <tr>...</tr>\n        </table>\n    </div>\n\n    \x3c!-- Second item --\x3e\n    <div>\n        <table>\n            \x3c!-- The second row of original table --\x3e\n            <tr>...</tr>\n        </table>\n    </div>\n\n    \x3c!-- ... --\x3e\n</div>\n\n\x3c!-- The original table --\x3e\n<table>\n    ...\n</table>\n~~~\n\nIt's worth noting that when cloning cells in each item, we have to set the cell width same as the original cell.\nSo the item looks like the original row completely:\n\n~~~ javascript\ncells.forEach(function(cell) {\n    const newCell = cell.cloneNode(true);\n    // Set the width as the original cell\n    newCell.style.width = `${parseInt(window.getComputedStyle(cell).width)}px`;\n    newRow.appendChild(newCell);\n});\n~~~\n\n## Determine the indexes of dragging and target rows\n\n~~~ javascript\nlet draggingEle;        // The dragging element\nlet draggingRowIndex;   // The index of dragging row\n\nconst mouseDownHandler = function(e) {\n    // Get the original row\n    const originalRow = e.target.parentNode;\n    draggingRowIndex = [].slice.call(table.querySelectorAll('tr')).indexOf(originalRow);\n};\n\nconst mouseMoveHandler = function(e) {\n    if (!isDraggingStarted) {\n        cloneTable();\n\n        // Query the dragging element\n        draggingEle = [].slice.call(list.children)[draggingRowIndex];\n    }\n};\n\nconst mouseUpHandler = function() {\n    // Get the end index\n    const endRowIndex = [].slice.call(list.children).indexOf(draggingEle);\n};\n~~~\n\nAs we have `draggingRowIndex` and `endRowIndex`, it's now easy to check if user drops to the top or bottom of table.\nAnd we can decide how to move the target row [before or after the dragging row](/insert-an-element-after-or-before-other-element):\n\n~~~ javascript\nconst mouseUpHandler = function() {\n    // Move the dragged row to `endRowIndex`\n    let rows = [].slice.call(table.querySelectorAll('tr'));\n    draggingRowIndex > endRowIndex\n        // User drops to the top\n        ? rows[endRowIndex].parentNode.insertBefore(rows[draggingRowIndex], rows[endRowIndex])\n        // User drops to the bottom\n        : rows[endRowIndex].parentNode.insertBefore(rows[draggingRowIndex], rows[endRowIndex].nextSibling);\n};\n~~~\n\nFollowing is the final demo. Try to drag and drop the first cell of any row.\n"}),a.a.createElement(r.a,{src:"/demo/drag-and-drop-table-row/index.html"}),a.a.createElement(s.a,{slugs:["add-or-remove-class-from-an-element","attach-or-detach-an-event-handler","calculate-the-mouse-position-relative-to-an-element","clone-an-element","create-an-element","drag-and-drop-element-in-a-list","drag-and-drop-table-column","get-siblings-of-an-element","insert-an-element-after-or-before-other-element","loop-over-a-nodelist","make-a-draggable-element","remove-an-element","select-an-element-or-list-of-elements","set-css-style-for-an-element"]}))}}}]);
//# sourceMappingURL=posts-drag-and-drop-table-row.0202a9bb8f26bde3f6d1.js.map