(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{"430h":function(e,n,t){"use strict";t.r(n);var l=t("q1tI"),o=t.n(l),a=t("TJpk"),i=t("mcK/"),r=t("Ov9x"),s=t("2G++");n.default=function(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(a.Helmet,null,o.a.createElement("meta",{name:"keywords",content:"\n            addEventListener, drag drop list, drag drop table row, getBoundingClientRect, insert node before,\n            insertBefore, mousedown event, mousemove event, mouseup event, next sibling,\n            nextElementSibling, previous sibling, previousElementSibling, sortable list, swap nodes\n        "})),o.a.createElement(r.a,{content:"\nBefore taking a look at this example, it's recommended to visit this [post](/drag-and-drop-element-in-a-list) to know\nhow we can drag and drop element in a list.\n\nThe same technique can be applied to the table columns. The basic idea is\n\n* When user starts moving a table column, we create a list of items. Each item is cloned from each column of table.\n* We show the list at the same position as table, and hide the table.\n* At this step, moving column around is actually moving the list item.\n* When user drags an item, we determine the index of target item within the list. And swap the columns associated with the dragging and end indexes.\n\nLet's get started with the basic markup of table:\n\n~~~ html\n<table id=\"table\">\n    ...\n</table>\n~~~\n\n## Basic setup\n\nAs mentioned in the [Drag and drop element in a list](/drag-and-drop-element-in-a-list) example, we need handle three events:\n\n* `mousedown` for the all header cells, so user can click and drag the first cell in each column\n* `mousemove` for `document`: This event triggers when user moves the column around, and we will create and insert a placeholder column\ndepending on the direction (left or right)\n* `mouseup` for `document`: This event occurs when user drags the column.\n\nHere is the skeleton of these event handlers:\n\n~~~ javascript\n// Query the table\nconst table = document.getElementById('table');\n\nconst mouseDownHandler = function(e) {\n    ...\n\n    // Attach the listeners to `document`\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler);\n};\n\nconst mouseMoveHandler = function(e) {\n    ...\n};\n\nconst mouseUpHandler = function() {\n    ...\n    // Remove the handlers of `mousemove` and `mouseup`\n    document.removeEventListener('mousemove', mouseMoveHandler);\n    document.removeEventListener('mouseup', mouseUpHandler);\n};\n\n// Query all header cells\ntable.querySelectorAll('th').forEach(function(headerCell) {\n    // Attach event handler\n    headerCell.addEventListener('mousedown', mouseDownHandler);\n});\n~~~\n\n## Clone the table when user is moving a column\n\nSince this task is performed once, we need a flag to track if it's executed:\n\n~~~ javascript\nlet isDraggingStarted = false;\n\nconst mouseMoveHandler = function(e) {\n    if (!isDraggingStarted) {\n        isDraggingStarted = true;\n\n        cloneTable();\n    }\n    ...\n};\n~~~\n\n`cloneTable` creates an element that has the same position as the table, and is shown right before the table:\n\n~~~ javascript\nlet list;\n\nconst cloneTable = function() {\n    // Get the bounding rectangle of table\n    const rect = table.getBoundingClientRect();\n\n    // Create new element\n    list = document.createElement('div');\n    \n    // Set the same position as table\n    list.style.position = 'absolute';\n    list.style.left = `${rect.left}px`;\n    list.style.top = `${rect.top}px`;\n\n    // Insert it before the table\n    table.parentNode.insertBefore(list, table);\n\n    // Hide the table\n    table.style.visibility = 'hidden';\n};\n~~~\n\nImagine that `list` consists of items which are cloned from the table columns:\n\n~~~ javascript\nconst cloneTable = function() {\n    ...\n\n    // Get all cells\n    const originalCells = [].slice.call(table.querySelectorAll('tbody td'));\n\n    const originalHeaderCells = [].slice.call(table.querySelectorAll('th'));\n    const numColumns = originalHeaderCells.length;\n\n    // Loop through the header cells\n    originalHeaderCells.forEach(function(headerCell, headerIndex) {\n        const width = parseInt(window.getComputedStyle(headerCell).width);\n\n        // Create a new table from given row\n        const item = document.createElement('div');\n        item.classList.add('draggable');\n\n        const newTable = document.createElement('table');\n\n        // Header\n        const th = headerCell.cloneNode(true);\n        let newRow = document.createElement('tr');\n        newRow.appendChild(th);\n        newTable.appendChild(newRow);\n\n        const cells = originalCells.filter(function(c, idx) {\n            return (idx - headerIndex) % numColumns === 0;\n        });\n        cells.forEach(function(cell) {\n            const newCell = cell.cloneNode(true);\n            newRow = document.createElement('tr');\n            newRow.appendChild(newCell);\n            newTable.appendChild(newRow);\n        });\n\n        item.appendChild(newTable);\n        list.appendChild(item);\n    });\n};\n~~~\n\nAfter this step, we have the following `list`:\n\n~~~ html\n\x3c!-- The list --\x3e\n<div>\n    \x3c!-- First item --\x3e\n    <div>\n        <table>\n            \x3c!-- The first column of original table --\x3e\n            <tr>...</tr>\n            <tr>...</tr>\n            ...\n        </table>\n    </div>\n\n    \x3c!-- Second item --\x3e\n    <div>\n        <table>\n            \x3c!-- The second column of original table --\x3e\n            <tr>...</tr>\n            <tr>...</tr>\n            ...\n        </table>\n    </div>\n\n    \x3c!-- ... --\x3e\n</div>\n\n\x3c!-- The original table --\x3e\n<table>\n    ...\n</table>\n~~~\n\nIt's worth noting that when cloning cells in each item, we have to set the cell width same as the original cell.\nSo the item looks like the original column completely:\n\n~~~ javascript\noriginalHeaderCells.forEach(function(headerCell, headerIndex) {\n    // Get the width of original cell\n    const width = parseInt(window.getComputedStyle(headerCell).width);\n\n    newTable.style.width = `${width}px`;\n\n    cells.forEach(function(cell) {\n        const newCell = cell.cloneNode(true);\n        newCell.style.width = `${width}px`;\n        ...\n    });\n});\n~~~\n\n## Determine the indexes of dragging and target columns\n\n~~~ javascript\nlet draggingEle;        // The dragging element\nlet draggingRowIndex;   // The index of dragging column\n\nconst mouseDownHandler = function(e) {\n    // Get the index of dragging column\n    draggingColumnIndex = [].slice.call(table.querySelectorAll('th')).indexOf(e.target);\n};\n\nconst mouseMoveHandler = function(e) {\n    if (!isDraggingStarted) {\n        cloneTable();\n\n        // Query the dragging element\n        draggingEle = [].slice.call(list.children)[draggingColumnIndex];\n    }\n};\n\nconst mouseUpHandler = function() {\n    // Get the end index\n    const endColumnIndex = [].slice.call(list.children).indexOf(draggingEle);\n};\n~~~\n\nAs we have `draggingColumnIndex` and `endColumnIndex`, it's now easy to check if user drops to the left or right of table.\nAnd we can decide how to move the target column [before or after the dragging column](/insert-an-element-after-or-before-other-element):\n\n~~~ javascript\nconst mouseUpHandler = function() {\n    // Move the dragged column to `endColumnIndex`\n    table.querySelectorAll('tr').forEach(function(row) {\n        const cells = [].slice.call(row.querySelectorAll('th, td'));\n        draggingColumnIndex > endColumnIndex\n            ? cells[endColumnIndex].parentNode.insertBefore(cells[draggingColumnIndex], cells[endColumnIndex])\n            : cells[endColumnIndex].parentNode.insertBefore(cells[draggingColumnIndex], cells[endColumnIndex].nextSibling);\n    });\n};\n~~~\n\nFollowing is the final demo. Try to drag and drop the first cell of any column.\n"}),o.a.createElement(i.a,{src:"/demo/drag-and-drop-table-column/index.html"}),o.a.createElement(s.a,{slugs:["add-or-remove-class-from-an-element","attach-or-detach-an-event-handler","calculate-the-mouse-position-relative-to-an-element","clone-an-element","create-an-element","drag-and-drop-element-in-a-list","get-siblings-of-an-element","insert-an-element-after-or-before-other-element","loop-over-a-nodelist","make-a-draggable-element","remove-an-element","select-an-element-or-list-of-elements","set-css-style-for-an-element"]}))}}}]);
//# sourceMappingURL=posts-drag-and-drop-table-column.1715a81f9d673b23c02a.js.map