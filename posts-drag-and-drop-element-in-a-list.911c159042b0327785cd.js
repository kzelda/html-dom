(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{Ljle:function(e,n,t){"use strict";t.r(n);var o=t("q1tI"),a=t.n(o),l=t("TJpk"),r=t("mcK/"),i=t("Ov9x"),s=t("2G++");n.default=function(){return a.a.createElement(a.a.Fragment,null,a.a.createElement(l.Helmet,null,a.a.createElement("meta",{name:"keywords",content:"\n            addEventListener, drag drop list, getBoundingClientRect, insert node before, insertBefore,\n            mousedown event, mousemove event, mouseup event, next sibling, nextElementSibling,\n            previous sibling, previousElementSibling, sortable list, swap nodes\n        "})),a.a.createElement(i.a,{content:"\nIn this example, we will create a sortable list whose items can be dragged and dropped inside it:\n\n~~~ html\n<div id=\"list\">\n    <div class=\"draggable\">A</div>\n    <div class=\"draggable\">B</div>\n    <div class=\"draggable\">C</div>\n    <div class=\"draggable\">D</div>\n    <div class=\"draggable\">E</div>\n</div>\n~~~\n\nEach item has class of `draggable` indicating that user can drag it:\n\n~~~ css\n.draggable {\n    cursor: move;\n    user-select: none;\n}\n~~~\n\n## Make items draggable\n\nBy using the similar approach mentioned in the [_Make a draggable element_](/make-a-draggable-element) post,\nwe can turn each item into a draggable element:\n\n~~~ javascript\n// The current dragging item\nlet draggingEle;\n\n// The current position of mouse relative to the dragging element\nlet x = 0;\nlet y = 0;\n\nconst mouseDownHandler = function(e) {\n    const draggingEle = e.target;\n\n    // Calculate the mouse position\n    const rect = draggingEle.getBoundingClientRect();\n    x = e.pageX - rect.left;\n    y = e.pageY - rect.top;\n\n    // Attach the listeners to `document`\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler);\n};\n\nconst mouseMoveHandler = function(e) {\n    // Set position for dragging element\n    draggingEle.style.position = 'absolute';\n    draggingEle.style.top = `${e.pageY - y}px`; \n    draggingEle.style.left = `${e.pageX - x}px`;\n};\n~~~\n\nThe `mouseup` event handler will remove the position styles of dragging item and cleans up the event handlers:\n\n~~~ javascript\nconst mouseUpHandler = function() {\n    // Remove the position styles\n    draggingEle.style.removeProperty('top');\n    draggingEle.style.removeProperty('left');\n    draggingEle.style.removeProperty('position');\n\n    x = null;\n    y = null;\n    draggingEle = null;\n\n    // Remove the handlers of `mousemove` and `mouseup`\n    document.removeEventListener('mousemove', mouseMoveHandler);\n    document.removeEventListener('mouseup', mouseUpHandler);\n};\n~~~\n\nNow we can attach the `mousedown` event to each item by [looping over](/loop-over-a-nodelist) the list of items:\n\n~~~ javascript\n// Query the list element\nconst list = document.getElementById('list');\n\n// Query all items\n[].slice.call(list.querySelectorAll('.draggable')).forEach(function(item) {\n    item.addEventListener('mousedown', mouseDownHandler);\n});\n~~~\n\n## Add a placeholder\n\nLet's take a look at the list of items again:\n\n~~~ html\nA\nB\nC\nD\nE\n~~~\n\nWhen we drag an item, `C` for example, the next item (`D`) will move up to the top and takes the area of the dragging element (`C`).\nTo fix that, we create a dynamic placeholder element and [insert it](/insert-an-element-after-or-before-other-element) right before the dragging element.\nThe height of placeholder must be the same as dragging element.\n\nThe placeholder is created once during the mouse moving, so we add a new flag `isDraggingStarted` to track it:\n\n~~~ javascript\nlet placeholder;\nlet isDraggingStarted = false;\n\nconst mouseMoveHandler = function(e) {\n    const draggingRect = draggingEle.getBoundingClientRect();\n\n    if (!isDraggingStarted) {\n        // Update the flag\n        isDraggingStarted = true;\n        \n        // Let the placeholder take the height of dragging element\n        // So the next element won't move up\n        placeholder = document.createElement('div');\n        placeholder.classList.add('placeholder');\n        draggingEle.parentNode.insertBefore(\n            placeholder,\n            draggingEle.nextSibling\n        );\n\n        // Set the placeholder's height\n        placeholder.style.height = `${draggingRect.height}px`;\n    }\n    \n    ...\n}\n~~~\n\nThe placeholder will be [removed](/remove-an-element) as soon as the users drop the item:\n\n~~~ javascript\nconst mouseUpHandler = function() {\n    // Remove the placeholder\n    placeholder && placeholder.parentNode.removeChild(placeholder);\n    \n    ...\n};\n~~~\n\nHere is the order of element when user drags and moves an item around:\n\n~~~ html\nA\nB\nplaceholder   <- The dynamic placeholder\nC             <- The dragging item\nD\nE\n~~~\n\n## Determine if user moves item up or down\n\nFirst of all, we need a helper function to check if an item is above or below another one.\n\nA `nodeA` is treated as above of `nodeB` if the horizontal center point of `nodeA` is less than `nodeB`.\nThe center point of a node can be calculated by taking the sum of its top and half of its height:\n\n~~~ javascript\nconst isAbove = function(nodeA, nodeB) {\n    // Get the bounding rectangle of nodes\n    const rectA = nodeA.getBoundingClientRect();\n    const rectB = nodeB.getBoundingClientRect();\n\n    return (rectA.top + rectA.height / 2 < rectB.top + rectB.height / 2);\n};\n~~~\n\nAs user moves the item around, we define the previous and next [sibling items](/get-siblings-of-an-element):\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    // The current order:\n    // prevEle\n    // draggingEle\n    // placeholder\n    // nextEle\n    const prevEle = draggingEle.previousElementSibling;\n    const nextEle = placeholder.nextElementSibling;    \n};\n~~~\n\nIf user moves the item to the top, we will swap the placeholder and the previous item:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    ...\n\n    // User moves item to the top\n    if (prevEle && isAbove(draggingEle, prevEle)) {\n        // The current order    -> The new order\n        // prevEle              -> placeholder\n        // draggingEle          -> draggingEle\n        // placeholder          -> prevEle\n        swap(placeholder, draggingEle);\n        swap(placeholder, prevEle);\n        return;\n    }\n};\n~~~\n\nSimilarly, we will swap the next and dragging item if we detect that user moves item down to the bottom:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    ...\n\n    // User moves the dragging element to the bottom\n    if (nextEle && isAbove(nextEle, draggingEle)) {\n        // The current order    -> The new order\n        // draggingEle          -> nextEle\n        // placeholder          -> placeholder\n        // nextEle              -> draggingEle\n        swap(nextEle, placeholder);\n        swap(nextEle, draggingEle);\n    }\n};\n~~~\n\nHere, `swap` is a small function for [swapping two nodes](/swap-two-nodes):\n\n~~~ javascript\nconst swap = function(nodeA, nodeB) {\n    const parentA = nodeA.parentNode;\n    const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;\n\n    // Move `nodeA` to before the `nodeB`\n    nodeB.parentNode.insertBefore(nodeA, nodeB);\n\n    // Move `nodeB` to before the sibling of `nodeA`\n    parentA.insertBefore(nodeB, siblingA);\n};\n~~~\n\nFollowing is the final demo. Try to drag and drop any item!\n"}),a.a.createElement(r.a,{src:"/demo/drag-and-drop-element-in-a-list/index.html"}),a.a.createElement(s.a,{slugs:["add-or-remove-class-from-an-element","attach-or-detach-an-event-handler","calculate-the-mouse-position-relative-to-an-element","create-an-element","drag-and-drop-table-column","drag-and-drop-table-row","get-siblings-of-an-element","insert-an-element-after-or-before-other-element","loop-over-a-nodelist","make-a-draggable-element","remove-an-element","select-an-element-or-list-of-elements","set-css-style-for-an-element"]}))}}}]);
//# sourceMappingURL=posts-drag-and-drop-element-in-a-list.911c159042b0327785cd.js.map