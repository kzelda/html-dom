(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{EFjH:function(e,n,t){"use strict";t.r(n);var i=t("q1tI"),s=t.n(i),r=t("TJpk"),o=t("mcK/"),a=t("Ov9x"),l=t("2G++");n.default=function(){return s.a.createElement(s.a.Fragment,null,s.a.createElement(r.Helmet,null,s.a.createElement("meta",{name:"keywords",content:"\n            addEventListener, data attribute, getBoundingClientRect, mousedown event, mousemove event,\n            mouseup event, next sibling, nextElementSibling, previous sibling, previousElementSibling,\n            set css style, split view\n        "})),s.a.createElement(a.a,{content:"\nIn this post, we'll add an element to resize children of a given element.\nThe original element could be organized as below:\n\n~~~ html\n<div style=\"display: flex\">\n    \x3c!-- Left element --\x3e\n    <div>Left</div>\n\n    \x3c!-- The resizer --\x3e\n    <div class=\"resizer\" id=\"dragMe\"></div>\n\n    \x3c!-- Right element --\x3e\n    <div>Right</div>\n</div>\n~~~\n\nIn order to place the left, resizer and right elements in the same row, we add the `display: flex` style to the parent.\n\n## Update the width of left side when dragging the resizer element\n\nIt's recommended to look at this [post](/make-a-draggable-element) to see how we can make an element draggable.\n\nIn our case, the resizer can be dragged horizontally. First, we have to store the mouse position and the left side's width when user starts clicking the resizer:\n\n~~~ javascript\n// Query the element\nconst resizer = document.getElementById('dragMe');\nconst leftSide = resizer.previousElementSibling;\nconst rightSide = resizer.nextElementSibling;\n\n// The current position of mouse\nlet x = 0;\nlet y = 0;\n\n// Width of left side\nlet leftWidth = 0;\n\n// Handle the mousedown event\n// that's triggered when user drags the resizer\nconst mouseDownHandler = function(e) {\n    // Get the current mouse position\n    x = e.clientX;\n    y = e.clientY;\n    leftWidth = leftSide.getBoundingClientRect().width;\n\n    // Attach the listeners to `document`\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler);\n};\n\n// Attach the handler\nresizer.addEventListener('mousedown', mouseDownHandler);\n~~~\n\nLooking at the structure of our markup, the left and right side are previous and next sibling of resizer.\nThey can be [retrieved](/get-siblings-of-an-element) as you see above:\n\n~~~ javascript\nconst leftSide = resizer.previousElementSibling;\nconst rightSide = resizer.nextElementSibling;\n~~~\n\nNext, when user moves the mouse around, we determine how far the mouse has been moved and then update the width for the left side:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    // How far the mouse has been moved\n    const dx = e.clientX - x;\n    const dy = e.clientY - y;\n\n    const newLeftWidth = (leftWidth + dx) * 100 / resizer.parentNode.getBoundingClientRect().width;\n    leftSide.style.width = `${newLeftWidth}%`;\n};\n~~~\n\nThere're two important things that I would like to point out here:\n\n* The width of left side is set based on the number of percentages of the parent's width. It keeps the ratio of left and side widths,\nand makes two sides look good when user resizes the browser.\n* It's not necessary to update the width of right side if we always force it to take the remaining width:\n\n~~~ html\n<div style=\"display: flex\">\n    \x3c!-- Left element --\x3e\n    ...\n\n    \x3c!-- The resizer --\x3e\n    ...\n\n    \x3c!-- Right element --\x3e\n    <div style=\"flex: 1 1 0%;\">Right</div>\n</div>\n~~~\n\n## Fix the flickering issue\n\nWhen user moves the resizer, we should update its cursor:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    ...\n    resizer.style.cursor = 'col-resize';\n};\n~~~\n\nBut it causes another issue. As soon as the user moves the mouse around, we will see the default mouse cursor beause the\nmouse isn't on top of the resizer. User will see the screen flickering because the cursor is changed continuously.\n\nTo fix that, we set the cursor for the entire page:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    ...\n    document.body.style.cursor = 'col-resize';\n};\n~~~\n\nWe also prevent the mouse events and text selection in both sides by [setting the values](/set-css-style-for-an-element)\nfor `user-select` and `pointer-events`:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    ...\n    leftSide.style.userSelect = 'none';\n    leftSide.style.pointerEvents = 'none';\n\n    rightSide.style.userSelect = 'none';\n    rightSide.style.pointerEvents = 'none';\n};\n~~~\n\nThese styles are removed right after the user stops moving the mouse:\n\n~~~ javascript\nconst mouseUpHandler = function() {\n    resizer.style.removeProperty('cursor');\n    document.body.style.removeProperty('cursor');\n\n    leftSide.style.removeProperty('user-select');\n    leftSide.style.removeProperty('pointer-events');\n\n    rightSide.style.removeProperty('user-select');\n    rightSide.style.removeProperty('pointer-events');\n\n    // Remove the handlers of `mousemove` and `mouseup`\n    document.removeEventListener('mousemove', mouseMoveHandler);\n    document.removeEventListener('mouseup', mouseUpHandler);\n};\n~~~\n\nBelow is the demo that you can play with.\n"}),s.a.createElement(o.a,{src:"/demo/create-resizable-split-views/index.html"}),s.a.createElement(a.a,{content:"\n## Support vertical direction\n\nIt's easy to support splitting the side vertically. Instead of updating the width of left side, now we update the height of the top side:\n\n~~~ javascript\nconst prevSibling = resizer.previousElementSibling;\nlet prevSiblingHeight = 0;\n\nconst mouseDownHandler = function(e) {\n    const rect = prevSibling.getBoundingClientRect();\n    prevSiblingHeight = rect.height;\n};\n\nconst mouseMoveHandler = function(e) {\n    const h = (prevSiblingHeight + dy) * 100 / resizer.parentNode.getBoundingClientRect().height;\n    prevSibling.style.height = `${h}%`;\n};\n~~~\n\nWe also change the cursor when user moves the resizer element:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    ...\n    resizer.style.cursor = 'row-resize';\n    document.body.style.cursor = 'row-resize';\n};\n~~~\n\n## Support both directions\n\nLet's say that the right side wants to be split into two resizable elements. \n\nWe have two resizer elements currently. To indicate the splitting direction for each resizer, we add a custom attribute `data-direction`:\n\n~~~ html\n<div style=\"display: flex\">\n    <div>Left</div>\n    <div class=\"resizer\" data-direction=\"horizontal\"></div>\n\n    \x3c!-- The right side --\x3e\n    <div style=\"display: flex; flex: 1 1 0%; flex-direction: column\">\n        <div>Top</div>\n        <div class=\"resizer\" data-direction=\"vertical\"></div>\n        <div style=\"flex: 1 1 0%\">Bottom</div>\n    </div>\n</div>\n~~~\n\nLater, we can [retrieve the attribute](/get-set-and-remove-data-attributes) from the resizer element:\n\n~~~ javascript\nconst direction = resizer.getAttribute('data-direction') || 'horizontal';\n~~~\n\nThe logic of setting the width or height of previous sibling depends on the direction:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    switch (direction) {\n        case 'vertical':\n            const h = (prevSiblingHeight + dy) * 100 / resizer.parentNode.getBoundingClientRect().height;\n            prevSibling.style.height = `${h}%`;\n            break;\n        case 'horizontal':\n        default:\n            const w = (prevSiblingWidth + dx) * 100 / resizer.parentNode.getBoundingClientRect().width;\n            prevSibling.style.width = `${w}%`;\n            break;\n    }\n\n    const cursor = direction === 'horizontal' ? 'col-resize' : 'row-resize';\n    resizer.style.cursor = cursor;\n    document.body.style.cursor = cursor;\n\n    ...\n};\n~~~\n\n> ## Tip\n>\n> Using custom `data-` attribute is a good way to manage variables associated with the element.\n\nEnjoy the demo!\n"}),s.a.createElement(o.a,{src:"/demo/create-resizable-split-views/direction.html"}),s.a.createElement(l.a,{slugs:["attach-or-detach-an-event-handler","get-set-and-remove-data-attributes","get-siblings-of-an-element","loop-over-a-nodelist","make-a-draggable-element","set-css-style-for-an-element"]}))}}}]);
//# sourceMappingURL=posts-create-resizable-split-views.07721345759e762c0125.js.map